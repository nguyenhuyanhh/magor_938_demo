\chapter{Summary of Work Done}

This chapter presents a summary of the work done so far for the project. Section 2.1 covers the implemented system architecture, while Section 2.2 details the modules implemented for the integrated system.

The source code for the system has been uploaded to GitHub; GitHub also serves as the version control and issue management system for the project.

\section{System Architecture}

This section outlines the architecture of the implemented transcription system. It comprises two independent components --- \textit{modules} and \textit{data} --- each resides in its own subfolder within the system. The main system executable links these two components together; it executes \textit{procedures}, which are collections of modules in a pipeline, to complete a transcription.

The top level folder structure is as follows:

\begin{lstlisting}
    crawl/
        --raw files--
    data/
        --data files--
    modules/
        --module files--
    system.py               # system executable
    manifest.json           # system manifest
\end{lstlisting}

The whole system would be implemented in Python, using JSON as the manifest language. The components of the system architecture would be detailed below.

\subsection{Data Folders}

The data used in the system are of two types. The first type is raw data, which are unprocessed audio or video files; these files are stored under \verb|crawl/|. The second type is processed data, which are stored under \verb|data/| in a specialised folder structure:

\begin{lstlisting}
    data/
        file_id/
            raw/
                --the raw file--
            module_1/
                --output for module 1--
            module_2/
                --output for module 2--
            ...
            module_n/
                --output for module n--
            temp/
                module_1/
                    --temporary files for module 1--
                ...
\end{lstlisting}

Under this folder structure, at system startup the system executable would import the raw file from \verb|crawl/| into the \verb|data/file_id/raw/| subfolder, with the \verb|file_id| being a unique identifier. As a procedure is being executed, individual module's output files would be stored in the respective subfolder under \verb|data/file_id|, while the module's temporary files would be stored under \verb|data/file_id/temp|.

This structure allows the system to be fully modular; any module would only need to know its own folder to dump Ã­ts output, and practically any operation could be traced to the module level. Individual modules would be responsible in implementing this structure.

\subsection{Modules}

All modules in the system are placed under the subfolder \verb|modules/| according to the following folder structure:

\begin{lstlisting}
    modules/
        module_id_1/
            setup           # module setup script
            module.py       # module executable
            manifest.json   # module manifest
            --optional module data and executables--
        module_id_2/
            ...
        ...            
\end{lstlisting}

Each module has its own folder; the folder name is a module identifier in the form of \verb|module_name-version|. This allows multiple versions of a module to co-exist in the system. In each module folder there are three compulsory components --- a \verb|setup| script to setup the module and all its dependencies, a Python executable \verb|module.py| to call the module, and a manifest file in JSON format to specify the module details.

The manifest file must conform to this structure:

\begin{lstlisting}
    {
        "name": "module_name",
        "version": "module_version",
        "requires": [],
        "inputs": [],
        "outputs": []
    }
\end{lstlisting}

\verb|requires|, \verb|inputs| and \verb|outputs| are all JSON lists. \verb|requires| is a list of (optional) data files and executables required for the module's functionality; these files should be in place after running the \verb|setup| script. \verb|inputs| and \verb|outputs| are lists of subfolders under \verb|data/file_id|\footnote{See Section 2.1.1 Data Folders.} where the module would pull its input files and push its output files, respectively. In this way, the manifest file serves as a blueprint of the module to the system. This blueprint would be realised by the \verb|module.py| executable. Overall, the three compulsory components work together to ensure each module is self-contained.

\subsection{System Manifest and Executable}

The system manifest specifies system-level properties. It is a JSON file following this specification:

\begin{lstlisting}
    {
        "procedures": {
            "procedure_id_1": [],
            "procedure_id_2": [],
            ...
        },
        "file_types":{
            "audio": [],
            "video": []
        }
    }
\end{lstlisting}

\verb|file_types| would specify which file extensions are accepted by the system; only raw files of these types would be imported during runtime. The separation of \verb|audio| and \verb|video| types is used for future error-checking. \verb|procedures| as mentioned in the beginning of this chapter are pipelines of modules to perform a certain function. These procedures are specified in the manifest by unique \verb|procedure_ids|; each procedure is a list of \verb|module_ids|\footnote{See Section 2.1.2 Modules.} outlining the order of execution of the modules on the targeted audio or video file. In this way, the system manifest provides a blueprint of the whole system to the system executable; it would execute a procedure according to this flow:

\begin{itemize}
    \item Startup manifest checks --- load all module manifests and system manifest, perform error checks and eliminate all ``broken'' modules and procedures
    \item File import --- import the correct files from \verb|crawl/| into the data structure in \verb|data/|\footnote{See Section 2.1.1 Data Folders.}
    \item Pipeline --- call the modules in the procedure one-by-one in the order specified by the system manifest
\end{itemize}

Multiple procedures could be applied to one file, and multiple files could be processed in one run of the system executable.

\section{Modules Implemented}